package io.quarkiverse.tekton.cli.pipeline;

import java.nio.file.Path;
import java.util.*;

import io.fabric8.kubernetes.api.model.HasMetadata;
import io.fabric8.tekton.v1.Param;
import io.fabric8.tekton.v1.PipelineRun;
import io.fabric8.tekton.v1.WorkspaceBinding;
import io.quarkiverse.tekton.cli.common.Clients;
import io.quarkiverse.tekton.cli.common.PipelineRuns;
import io.quarkiverse.tekton.cli.common.WorkspaceBindings;
import io.quarkiverse.tekton.common.utils.Params;
import io.quarkiverse.tekton.common.utils.Projects;
import picocli.CommandLine.Command;
import picocli.CommandLine.Option;
import picocli.CommandLine.Parameters;
import picocli.CommandLine.Unmatched;

@Command(name = "exec", header = "Execute Tekton pipeline.")
public class PipelineExec extends AbstractPipelineCommand {

    @Parameters(index = "0", paramLabel = "PIPELINE", description = "Pipeline name.")
    String pipelineName;

    @Option(names = { "-r", "--regenerate" }, description = "Regenerate and reinstall the pipeline.")
    boolean regenerate = false;

    @Unmatched
    private List<String> pipelineArgs = new ArrayList<>();

    @Override
    public boolean shouldOverwrite() {
        return regenerate;
    }

    private static String USER_NAMESPACE;

    @Override
    public void process(List<HasMetadata> resources) {
        checkNamespace();
        readInstalledPipelines();
        readProjectPipelines(resources);
        // Reading the generated resources and assign them to their respective Map<String, String>
        WorkspaceBindings.readBindingResources(resources);

        Path projectRootDirPath = Projects.getProjectRoot();
        String projectName = Projects.getArtifactId(projectRootDirPath);

        if (regenerate) {
            getProjectPipeline(pipelineName).ifPresentOrElse(t -> {
                Clients.kubernetes().resource(t).serverSideApply();
                if (t instanceof io.fabric8.tekton.v1beta1.Pipeline v1beta1Pipeline) {
                    addInstalledPipeline(v1beta1Pipeline);
                }
                if (t instanceof io.fabric8.tekton.v1.Pipeline v1Pipeline) {
                    addInstalledPipeline(v1Pipeline);
                }
            }, () -> {
                throw new IllegalArgumentException("Failed to regenerate/reinstall Pipeline " + pipelineName + ".");
            });
        }

        if (!isInstalled(pipelineName)) {
            if (isProject(pipelineName)) {
                output.err().println("Pipeline " + pipelineName
                        + " not installed, but its available in the project. You can retry after installing it.");
            } else {
                output.err().println("Pipeline " + pipelineName + " not installed.");
            }
            return;
        } else {
            output.out().println("Executing Pipeline: " + pipelineName);
            HasMetadata t = getInstalledPipeline(pipelineName).get();
            List<WorkspaceBinding> workspaceBindings = new ArrayList<>();

            // Get the PipelineRun generated by the TektonProcessor
            PipelineRun pipelineRun = resources.stream()
                    .filter(PipelineRun.class::isInstance)
                    .map(PipelineRun.class::cast)
                    .findFirst()
                    .orElseThrow(() -> new IllegalStateException("No PipelineRun found"));

            // Convert the arguments passed by the CLI command as List<String> into a Map<String,String> where the key is equal to the left part of key=val
            List<Param> params = Params.create(pipelineArgs);
            pipelineRun.getSpec().setParams(params);

            // Bind any existing PVC, Secret or configMap to their respective workspace declared part of the Pipeline
            if (t instanceof io.fabric8.tekton.v1.Pipeline pipelineV1) {
                pipelineV1.getSpec().getWorkspaces().forEach(w -> {
                    String workspaceName = w.getName();

                    WorkspaceBindings.forName(projectName, workspaceName)
                            .or(() -> !Boolean.TRUE.equals(w.getOptional())
                                    ? WorkspaceBindings.forEmpty(projectName, workspaceName)
                                    : Optional.empty())
                            .ifPresent(workspaceBindings::add);
                });
            } else if (t instanceof io.fabric8.tekton.v1beta1.Pipeline pipelineV1beta1) {
                pipelineV1beta1.getSpec().getWorkspaces().forEach(w -> {
                    String workspaceName = w.getName();

                    WorkspaceBindings.forName(projectName, workspaceName)
                            .or(() -> !Boolean.TRUE.equals(w.getOptional())
                                    ? WorkspaceBindings.forEmpty(projectName, workspaceName)
                                    : Optional.empty())
                            .ifPresent(workspaceBindings::add);
                });
            }

            for (WorkspaceBinding binding : workspaceBindings) {
                WorkspaceBindings.createIfNeeded(binding);
            }
            pipelineRun.getSpec().setWorkspaces(workspaceBindings);

            if (Clients.kubernetes().resource(pipelineRun).inNamespace(Clients.getNamespace()).get() != null) {
                Clients.kubernetes().resource(pipelineRun).inNamespace(Clients.getNamespace()).delete();
            }

            pipelineRun = Clients.kubernetes().resource(pipelineRun).inNamespace(Clients.getNamespace()).serverSideApply();
            output.out().printf("Created PipelineRun %s.\n", pipelineRun.getMetadata().getName());
            PipelineRuns.waitUntilReady(pipelineRun.getMetadata().getName());
            PipelineRuns.log(pipelineRun.getMetadata().getName());
            return;
        }
    }
}
